// Prisma schema for KRAFTA

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

enum Role {
  CUSTOMER
  PROFESSIONAL
  ADMIN
}

enum BookingStatus {
  PENDING
  ACCEPTED
  PAID
  REJECTED
  COMPLETED
  CANCELLED
}

// SQLite doesn't support enums well, but Prisma handles it. 
// However, for array of enums, we need to use String.

model User {
  id             String    @id @default(cuid())
  name           String?
  email          String?   @unique
  emailVerified  DateTime?
  image          String?
  hashedPassword String?
  role           Role      @default(CUSTOMER)
  phone          String?

  accounts       Account[]
  sessions       Session[]

  technician     Technician?
  bookings       Booking[] @relation("CustomerBookings")
  reviews        Review[]  @relation("CustomerReviews")

  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
}

model Technician {
  id            String           @id @default(cuid())
  userId        String           @unique
  user          User             @relation(fields: [userId], references: [id])

  title         String
  bio           String
  skills        String           // Comma separated string
  categories    String           // Comma separated string of ServiceCategory
  baseRate      Int?
  hourlyRate    Int?

  city          String
  area          String
  latitude      Float?
  longitude     Float?

  isVerified    Boolean          @default(false)
  averageRating Float            @default(0)
  reviewCount   Int              @default(0)

  bookings      Booking[]        @relation("TechnicianBookings")
  reviews       Review[]         @relation("TechnicianReviews")

  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
}

model Booking {
  id             String         @id @default(cuid())

  customerId     String
  customer       User           @relation("CustomerBookings", fields: [customerId], references: [id])

  technicianId   String
  technician     Technician     @relation("TechnicianBookings", fields: [technicianId], references: [id])

  status         BookingStatus  @default(PENDING)
  requestedAt    DateTime       @default(now())
  scheduledFor   DateTime?
  completedAt    DateTime?

  description    String
  address        String
  priceQuoted    Int?

  review         Review?

  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
}

model Review {
  id           String      @id @default(cuid())

  bookingId    String      @unique
  booking      Booking     @relation(fields: [bookingId], references: [id])

  customerId   String
  customer     User        @relation("CustomerReviews", fields: [customerId], references: [id])

  technicianId String
  technician   Technician  @relation("TechnicianReviews", fields: [technicianId], references: [id])

  rating       Int
  comment      String

  createdAt    DateTime    @default(now())
}

// NextAuth models (Prisma adapter)

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? 
  access_token      String? 
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? 
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
